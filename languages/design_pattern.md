- [面向对象](#面向对象)
  - [面向对象的基础](#面向对象的基础)
  - [面向对象的原则](#面向对象的原则)
- [设计模式](#设计模式)
  - [_strategy_](#strategy)
  - [_observer_](#observer)
  - [_decorator_](#decorator)
  - [_factory_](#factory)
  - [_singleton_](#singleton)
  - [_command_](#command)
  - [_adapter_](#adapter)
  - [_template_](#template)
  - [_iterator_](#iterator)
  - [_composite_](#composite)
  - [_proxy_](#proxy)


# 面向对象

## 面向对象的基础

* 继承
* 封装
* 多态

## 面向对象的原则

* 将需要变化的代码独立出来，减少对不需要变化的代码的影响。
* 多用组合，少用继承。
* 针对接口编程，而不是针对实现编程。
* 对扩展开放，对修改关闭。
* 依赖倒置原则：依赖抽象而不是具体的类。
* 最少知识原则：在对象的方法中应该只调用：该对象的方法、该对象的组件的方法、形参的方法和该对象所创建的对象的方法。
* 让每个类保持单一责任。
* _base class_ 控制 _derived class_ 何时和如何参与。

# 设计模式

## _strategy_

* 目的：将 _需要变化的策略部分_ 和 _不需要变化的使用策略部分_ 进行独立。
* 方法：将 _需要变化的策略部分_ 抽象为接口，_策略_ 变化时只需要继承接口重新实现即可，_需要变化的策略部分_ 和 _不需要变化的使用策略部分_ 组合使用，而非继承。 

## _observer_

* 目的：当 _subject_ 数据发生改变时，_subject_ 会调用它所对应的所有 _observer_ 的相关接口，且不需要关心这些接口的细节。
* 方法：将 _subject_ 所对应的 _observer_ 加入到一个队列中。

## _decorator_

* 目的：在需要被装饰者的场合，可以使用装饰者来代替被装饰者，装饰者可以在被装饰者的行为前面或者后面加上特有行为，以实现特定的目的。
* 方法：装饰者和被装饰者有相同的基类(装饰者使用继承来和被装饰者成为相同类型，但不通过继承获取行为)，装饰者有一个实例指向被装饰者，装饰者可以通过这个实例来使用被装饰者。

## _factory_

* 目的：将类的实例化推迟到 _derived class_ 中。
* 方法：通过 _base class_ 的接口来创建静态类型为 _base class_ 而动态类型为 _derived class_ 的对象。

## _singleton_

* 目的：确保一个类只有一个实例。
* 方法：将类的构造函数声明为 _private_，并提供 _static public_ 的函数来返回对象。

## _command_ 
    
* 目的：将发送命令方和接收命令方进行解耦，发送命令方不需要 _了解_ 接收命令方和其所要执行的具体动作。
* 方法：将接收命令方和其所要执行的具体动作封装为一个命令接口，发送命令方通过调用该接口来执行接收命令方所要执行的具体动作。

## _adapter_ 

* 目的：让不兼容的接口变成兼容。
* 方法：将不兼容接口包装为适配器，然后通过适配器进行接口转换，让不兼容的接口变成兼容。

## _template_
    
* 目的：使 _derived class_ 可以在不改变算法架构的情况下，重新定义算法中的某些步骤。
* 方法：在 _base class_ 中实现算法架构，算法架构中的这些步骤可以在 _base class_ 中实现，也可以延迟到 _derived class_ 中实现。

## _iterator_ 

* 目的：可以顺序访问聚合对象中的各个元素，而又不暴露其内部各个元素的存储细节。
* 方法：抽象接口来访问聚合对象中的各个元素。

## _composite_

* 目的：可以用相同的接口去处理拥有树形结构关系的子节点和叶节点，其中子节点和叶节点是 _整体/部分_ 的关系。
* 方法：子节点和叶节点继承相同的接口或者基类，那么用户可以对此接口进行操作，而无需区分是子节点还是叶节点。

## _proxy_ 
        
* 目的：可以为一个对象提供代理，来管理对此对象的访问方式。
* 方法：代理类和被代理对象的类共同继承相同的接口或者基类，在代理对象中实例化被代理对象，被代理对象用于执行具体动作，在需要被代理对象时可以使用代理对象来进行代替。